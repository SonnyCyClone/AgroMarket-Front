trigger:
  branches:
    include: [ develop ]
  paths:
    exclude: [ README.md, .gitignore, azure-pipelines.yml, .gitattributes ]

pr:
  branches:
    include: [ '*' ]

# ===== VARIABLES =====
variables:
  azureSubscription: 'sc-azure-agromarket'   # Service Connection ARM (nombre exacto)
  artifactName: 'frontend'                   # Nombre del artefacto publicado
  zipName: 'frontend.zip'                    # Nombre del ZIP a desplegar
  feRoot: '.'                                # Carpeta raíz del proyecto Angular (ajusta si aplica)
  app_prd: 'az-agromarket-front'             # Azure Web App (Front)

# ===== AGENTE (self-hosted Windows) =====
pool:
  name: Default
  demands:
    - agent.name -equals agromarket-agent-win

# ============== STAGES ==============
stages:

# ------------ BUILD ------------
- stage: Build
  displayName: Build Angular
  jobs:
  - job: build
    displayName: Build job
    steps:
    - checkout: self
      clean: true
      fetchDepth: 0

    - task: NodeTool@0
      displayName: 'Use Node 20.x'
      inputs:
        versionSpec: '20.x'

    - script: |
        node -v
        npm -v
        echo AGENT_WORKFOLDER=%AGENT_WORKFOLDER%
        echo Build.SourcesDirectory=$(Build.SourcesDirectory)
      displayName: 'Mostrar versiones y paths'

    # ===== OPCIÓN C: Ajustar budgets SOLO en CI (sin modificar el repo) =====
    - powershell: |
        $ErrorActionPreference = 'Stop'
        Set-StrictMode -Version Latest

        $root = "$(feRoot)"
        $angularPath = Join-Path $root 'angular.json'
        if (-not (Test-Path $angularPath)) { throw "No se encontró angular.json en '$root'." }

        $json = Get-Content $angularPath -Raw | ConvertFrom-Json

        # Detectar primer proyecto (clave en projects)
        $projectName = $null
        foreach ($p in $json.projects.PSObject.Properties) { $projectName = $p.Name; break }
        if (-not $projectName) { throw "No se detectó ningún proyecto en angular.json (sección 'projects')." }

        $proj      = $json.projects.$projectName
        $buildCfgs = $proj.architect.build.configurations
        if (-not $buildCfgs) { throw "No se encontró 'architect.build.configurations' en el proyecto '$projectName'." }

        if (-not $buildCfgs.production) { $buildCfgs | Add-Member -NotePropertyName production -NotePropertyValue (@{}) }
        if (-not $buildCfgs.production.budgets) { $buildCfgs.production | Add-Member -NotePropertyName budgets -NotePropertyValue (@()) }

        $budgets = $buildCfgs.production.budgets

        # Función helper para upsert de budgets por type
        function Set-Or-AddBudget([string]$type, [string]$warn, [string]$err) {
          $existing = $null
          foreach ($b in $budgets) { if ($b.type -eq $type) { $existing = $b; break } }
          if ($existing -eq $null) {
            $new = [ordered]@{ type = $type; maximumWarning = $warn; maximumError = $err }
            $budgets += $new
          } else {
            $existing.maximumWarning = $warn
            $existing.maximumError   = $err
          }
        }

        # Relajar budgets solo para CI (valores seguros para tu caso actual)
        Set-Or-AddBudget -type 'anyComponentStyle' -warn '10kb'  -err '12kb'
        Set-Or-AddBudget -type 'initial'          -warn '500kb' -err '650kb'

        # Guardar cambios en el working dir del agente (no modifica tu repo remoto)
        ($json | ConvertTo-Json -Depth 100) | Set-Content $angularPath -Encoding UTF8

        Write-Host "Budgets de production ajustados SOLO para CI:"
        Get-Content $angularPath | Write-Host
      displayName: 'Ajustar budgets solo en CI'

    # Instala dependencias y compila Angular (con diagnósticos)
    - powershell: |
        $ErrorActionPreference = 'Stop'
        Set-StrictMode -Version Latest

        # 1) Validar raíz del proyecto
        $root = "$(feRoot)"
        $pkg = Join-Path $root 'package.json'
        if (-not (Test-Path $pkg)) { throw "No se encontró package.json en '$root'. Ajusta feRoot." }
        cd $root
        Write-Host "Working dir: $(Get-Location)"

        # 2) Limpiar estado previo
        if (Test-Path 'node_modules') { Remove-Item -Recurse -Force 'node_modules' }
        if (-not (Test-Path 'package-lock.json')) { throw "Falta package-lock.json (npm ci lo exige)." }

        # Cache npm
        $npmCache = "$env:AGENT_WORKFOLDER\_npmcache"
        if (-not (Test-Path $npmCache)) { New-Item -ItemType Directory -Force -Path $npmCache | Out-Null }
        npm config set cache "$npmCache" --global | Out-Null
        npm config set fund false --global | Out-Null
        npm config set audit false --global | Out-Null

        if (Test-Path '.npmrc') { Write-Host ".npmrc detectado (registry/auth)." }
        else { Write-Host "Sin .npmrc (asumiendo sin paquetes privados)." }

        # 3) Instalar
        Write-Host ">> npm ci (verbose)"
        npm ci --loglevel verbose
        $ciExit = $LASTEXITCODE
        if ($ciExit -ne 0) {
          Write-Warning "npm ci falló (exit $ciExit). Probando 'npm install --legacy-peer-deps'…"
          npm install --legacy-peer-deps --loglevel verbose
          $installExit = $LASTEXITCODE
          if ($installExit -ne 0) {
            $logsRoot = Join-Path $env:AGENT_WORKFOLDER '_npmcache\_logs'
            if (Test-Path $logsRoot) {
              $logDir = Get-ChildItem $logsRoot -Directory -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
              if ($logDir) {
                $log = Get-ChildItem $logDir.FullName -Filter *.log | Sort-Object LastWriteTime -Descending | Select-Object -First 1
                if ($log) {
                  Write-Host "===== npm debug log (${log.Name}) ====="
                  Get-Content $log.FullName -Raw | Write-Host
                }
              }
            }
            throw "npm install --legacy-peer-deps falló (exit $installExit)."
          }
        }

        # 4) Validar script build
        $pkgJson = Get-Content 'package.json' -Raw
        if ($pkgJson -notmatch '"build"\s*:\s*".+?"') { throw "No hay script 'build' en package.json (se espera 'ng build')." }

        # 5) Compilar
        Write-Host ">> ng build (production)"
        npm run build -- --configuration production --output-path "dist" --verbose
        if ($LASTEXITCODE -ne 0) { throw "ng build falló ($LASTEXITCODE)" }
      displayName: 'npm ci / install & ng build'

    # Empaqueta salida a ZIP
    - powershell: |
        $ErrorActionPreference = 'Stop'
        Set-StrictMode -Version Latest

        $srcRoot = "$(Build.SourcesDirectory)"
        $distRoot = Join-Path $srcRoot 'dist'

        if (-not (Test-Path $distRoot)) { throw "No existe 'dist' en $distRoot. ¿Falló el build?" }

        $sub = Get-ChildItem -Directory $distRoot | Select-Object -First 1
        if (-not $sub) { throw "No se encontró carpeta de salida en $distRoot (esperado /dist/<app>)." }

        $content = Join-Path $sub.FullName 'browser'
        if (-not (Test-Path $content)) { $content = $sub.FullName }

        $webConfig = Join-Path $srcRoot 'web.config'
        if (-not (Test-Path $webConfig)) { throw "Falta web.config en la raíz del repo ($srcRoot)." }
        Copy-Item -Force $webConfig (Join-Path $content 'web.config')

        $outDir = "$(Build.ArtifactStagingDirectory)"
        New-Item -ItemType Directory -Force -Path $outDir | Out-Null
        $zipPath = Join-Path $outDir "$(zipName)"
        if (Test-Path $zipPath) { Remove-Item -Force $zipPath }

        Write-Host "Creando ZIP en: $zipPath"
        Compress-Archive -Path (Join-Path $content '*') -DestinationPath $zipPath -Force
      displayName: 'Crear ZIP'

    - task: PublishPipelineArtifact@1
      displayName: 'Publicar artefacto (pipeline)'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: '$(artifactName)'

# ------------ DEPLOY PRD ------------
- stage: Deploy_PRD
  displayName: Deploy to PRD
  dependsOn: Build
  condition: and(succeeded(), in(variables['Build.SourceBranchName'], 'main','master','develop'))
  jobs:
  - deployment: deploy_prd
    displayName: Deploy to Web App
    environment: 'front-prd'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Descargar artefacto de pipeline'
            inputs:
              buildType: 'current'
              artifactName: '$(artifactName)'
              targetPath: '$(Pipeline.Workspace)/$(artifactName)'

          - task: AzureWebApp@1
            displayName: 'Deploy to $(app_prd)'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: 'webApp'
              appName: '$(app_prd)'
              package: '$(Pipeline.Workspace)/$(artifactName)/$(zipName)'
